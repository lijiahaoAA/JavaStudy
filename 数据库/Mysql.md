#### MySQL

> [关于索引]( https://www.cnblogs.com/fengqiang626/archive/2019/09/04/11459434.html )

***

1. #####  数据库的三范式是什么？

   [范式定义]( https://www.cnblogs.com/hxphp/p/7001947.html )

   - 第一范式：强调的是列的原子性，及数据库表的每一列都是不可分割的原子数据项。
   - 第二范式：要求实体的属性完全依赖于主关键字。消除了非主属性对于码( **假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。** )的部分依赖函数。
   - 第三范式：任何非主属性不依赖于其他非主属性。消除了非主属性对于码的传递函数依赖。

2. ##### 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？

   `InnoDB`表只会把自增主键的最大id记录在内存中，所以重启之后会导致最大id丢失。

   - 表类型如果是`MyISAM`，id为8。
   - 表类型如果是`InnoDB`，id为6。

3. ##### 如何获取当前数据库版本？

   select version()获取当前的MySQL数据库版本。

4. ##### 说一下 ACID 是什么？

   - Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。 
   - Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。 
   - Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 
   - Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

5. ##### char 和 varchar 的区别是什么？

   - char(n)：是固定长度类型，比如订阅 char(10)，当你输入`"abc"`三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。 效率高，但占用空间，只用于存储固定长度的，如密码的md5值。
   - varchar(n)：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的自己的长度。节省了空间。

6. ##### float 和 double 的区别是什么？

   - float最多可以存储8位的十进制数，并在内存中占4字节。
   - double最多可以存储16位的十进制数，并在内存中占8字节。

7. ##### MySQL 的内连接、左连接、右连接有什么区别？

   - 内连接：inner join，把匹配的关联数据显示出来。
   - 左连接：left join，左边的表全部显示出来，右边的表只显示符合条件的数据。
   - 右连接：right join，右边的表全部显示出来，左边的表只显示符合条件的数据。

8. ##### MySQL 索引是怎么实现的？

   索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。

   具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据了，所以索引的性能也是更好的。

9. ##### 怎么验证 MySQL 的索引是否满足需求？

   使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。

   explain 语法：explain select * from table where type=1。

10. ##### 说一下数据库的事务隔离？

    MySQL 的事务隔离是在 `MySQL. ini` 配置文件里添加的，在文件的最后添加：

    transaction-isolation = REPEATABLE-READ

    可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。

    - READ-UNCOMMITTED：未提交读，最低隔离级别，事务未提交前，就可被其他事务读取。（会出现幻读，脏读，不可重复读）
    - READ-COMMITTED：提交读，一个事务提交之后才能被其他事务读取到。（会造成幻读，不可重复读）
    - REPEATABLE-READ：可重复读，保证多次读取同一个数据时，其值都和事务刚开始时的内容是一致的，禁止读取到别的事务未提交的数据（会造成幻读）。
    - SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该级别能防止脏读、不可重复读、幻读。

11. ##### 说一下 MySQL 常用的引擎？==还需理解==

    `InnoDB` 引擎：`mysql 5.1` 后默认的数据库引擎，**提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束**，它的设计的**目标就是处理大数据容量的数据库系统**。MySQL 运行的时候，`InnoDB` 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。

    `MyIASM` 引擎：**不提供事务的支持，也不支持行级锁和外键**。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 `InnoDB` 不同的是，`MyIASM` 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果**表的读操作远远多于写操作时，并且不需要事务的支持**的，可以将 `MyIASM` 作为数据库引擎的首选。

12. ##### 说一下 MySQL 的行锁和表锁？

    `MyISAM`只支持表锁，`InnoDB`支持表锁和行锁，默认为行锁。

    - 表级锁：开销小，加锁快，不会出现死锁。锁力度大，发生锁冲突的概率最高，并发量最低。
    - 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。

13. ##### 说一下乐观锁和悲观锁？

    - 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。

    - 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。

    数据库的乐观锁（version或者CAS方式）需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。

14. ##### 说一下大表优化。

    当MySQL单表记录过大时，数据库的CRUD性能会明显下降，常见优化如下：

    - 限定数据的范围：务必禁止不带任何数据限制范围条件的查询语句（时间，大小等）。
    - 读写分离：主库负责写，从库负责读。
    - 垂直分区：简单来说就是把列比较多的表分开，通过共有的属性（一般是主键）进行关联。优点是简化表结构，减小I/O次数；缺点是会出现主键冗余，引起Join操作，让事务变得更加复杂。
    - 水平分区：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或库中，达到分布式的目的。分表只是解决了数据量大的问题，数据仍旧在同一机器上，并没有提高并发能力。所以最好水平拆分最好还是分库。

15. ##### 分库分表之后，id主键如何处理？

    分成多个表之后，每个表都是从一开始的，这样是不符合逻辑的。我们需要一个全局唯一的id来支持。

    生成全局id有以下几种方法：

    - UUID：不适合用于主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标识如文件的名字。
    - 数据库自增id：两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。生成id有序，但是需要独立部署数据库实例，成本高。
    - 利用Redis生成id：性能好，不依赖于数据库。但引入新的组件会造成形同复杂，可用性降低，编码复杂。
    - Twitter的snowflake算法：[ https://github.com/twitter-archive/snowflake ]( https://github.com/twitter-archive/snowflake )
    - 美团的Leaf分布式ID生成系统：[https://tech.meituan.com/2017/04/21/mt-leaf.html ]( https://tech.meituan.com/2017/04/21/mt-leaf.html )

16. ##### MySQL 问题排查都有哪些手段？

    - 使用explain命令查询SQL语句执行计划。
    - 开启慢查询( 让MySQL记录下查询超过指定时间的语句，我们将超过指定时间的[SQL语句](https://baike.baidu.com/item/SQL语句/5714895)查询 叫做慢查询)日志，查看慢查询的SQL。
    - 使用`show processlist`命令查看当前所有连接信息。

17. ##### 一条SQL语句在MySQL中是如何执行的？

    - 连接器：身份认证和权限相关（登录MySQL的时候）。
    - 查询缓存（8.0之后移除）：先查缓存。
    - 分析器：没有命中缓存，来到分析器分析SQL语句语义（抽取关键字）和正确性。
    - 优化器：MySQL认为的执行最优方案。
    - 执行器：执行语句，从存储引擎返回数据。

18. ##### MySQL高性能优化规范建议。

    [特别全面]( https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN%23rd )

    **数据库命令规范：**

    - 所有数据库对象名称必须使用小写字母并用下划线分割。
    - 所有数据库对象名称禁止使用MySQL保留关键字。
    - 数据库对象的命名要能做到见名识意。
    - 临时库表必须以tmp\_为前缀并以日期为后缀，备份表必须以bak\_为前缀以日期为后缀。

    **数据库基本设计规范：**

    - 所有表必须使用InnoDB存储引擎。
    - 数据库和表的字符集统一使用UTF-8。
    - 所有表和字段都要有注释（使用comment关键字）。
    - 单表数据量控制在500万以内。
    - 做到冷热数据分离，减小表的宽度：减少磁盘I/O，保证热数据的内存缓存命中率。
    - 禁止在表中建立预留字段。
    - 禁止在数据库文件中存储图片，文件等大的二进制文件数据：数据库只存文件地址信息。
    - 禁止在线上做数据库压力测试。
    - 禁止从开发环境，测试环境直接连接生成环境数据库。

    **数据库字段设计规范：**

    - 优先选择符合存储的需要的最小的数据类型。
    - 避免使用ENUM类型：修改ENUM类型需要使用ALTER语句，禁止使用数值作为ENUM的枚举值。
    - 尽可能把所有列定义为NOT NULL：虽然索引NULL需要额外的空间来保存，占用更多内存；但如果没有，再进行比较和计算时要对NULL值做特别的处理。
    - 使用TIMESTAMP（四个字节）或者DATETIME类型（八个字节）存储时间：字符串存储日期会导致占用内存更多，无法使用日期函数进行比较和计算。
    - 同财务相关的金额数据必须使用decimal类型：精准浮点，计算式不会丢失精度。

    **索引设计规范：**

    - 限制每张表上的索引数量，建议一张表不超过5个索引。

    - 禁止给表中的每一列都建立单独的索引。

    - 每个InnoDB表必须有主键：InnoDB是按照主键索引的顺序来继进行组织表的。

    - 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）

      - 重复索引示例：primary key(id)、index(id)、unique index(id)
      - 冗余索引示例：index(a,b,c)、index(a,b)、index(a)

    - 对于频繁的查询优先考虑使用覆盖索引

      > 覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引 

    **数据库SQL开发规范：**

    - 建议使用预编译语句进行数据库操作：相同语句可以进行使用一次的解析，提高处理效率。

    - 避免数据类型的隐式转换：隐式转换会导致索引失效

      > select name,phone from customer where id = '111'; 

    - 禁止使用select * 必须加具体的列和条件：消耗更多的CPU和IO以及网络带宽；无法使用覆盖索引。

    - 避免使用子查询，可以把子查询优化为Join操作：子查询的结果集无法使用索引。

      > 通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。 

    **数据库操作行为规范：**

    - 超百万行的批写量（update，insert，delete）操作，分多次执行。
    - 对于大表使用 pt-online-schema-change 修改表结构。
    - 对于程序连接数据库账号,遵循权限最小原则。

19. ##### 覆盖索引的优点。

    - **避免 Innodb 表进行索引的二次查询:** Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。
    - **可以把随机 IO 变成顺序 IO 加快查询效率:** 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。 

20. ##### 联合索引是什么？

    联合索引时指对表上的多个列合起来做一个索引，省的你查询的时候，where后面的条件字段一直再变，你就想给每个字段加索引的尴尬问题。联合索引的创建方法与单个索引的创建方法一样，不同之处在仅在于有多个索引列。

    ~~~SQL
    mysql> create table t(
        -> a int,
        -> b int,
        -> primary key(a),
        -> key idx_a_b(a,b)
        -> );
    Query OK, 0 rows affected (0.11 sec)
    ~~~

    建立联合索引的原则：最左匹配原则，区分度高得放在最左边，一次，范围查询条件尽可能往后放。

21. ##### 什么是覆盖索引？

    即从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。

    使用覆盖索引的一个好处是：辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作

22. ##### 什么叫做慢查询?

    分析MySQL语句查询性能的方法除了使用 EXPLAIN 输出执行计划，还可以让MySQL记录下查询超过指定时间（long_query_time参数设定的时间）的语句，我们将超过指定时间的[SQL语句](https://baike.baidu.com/item/SQL语句/5714895)查询称为“慢查询”。 

23. ##### 如何做 MySQL 的性能优化？

    - 为搜索字段创建索引。
    - 避免使用select *，列出需要查询的字段。
    - 垂直分库分表。
    - 选择正确的存储引擎。

