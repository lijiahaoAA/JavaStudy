### JVM

***

1. ##### 说一下JVM的主要组成部分？及其作用？

   ![](https://img-blog.csdn.net/20171207192926318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdzMwNDU4NzI4MTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   - class loader（类加载器）：加载类文件到内存。只负责加载，不负责执行。

   - exectution engine（解释器/执行引擎）：负责解释命令，交由操作系统执行。

   - native interface（本地接口）：融合不同的语言为java所用。

   - Runtimedata area（运行时数据区）：程序被加载到这里，才开始执行。

   - stack（栈内存）：java程序的运行区，在线程创建时创建，生命周期跟随线程的生命周期。对于栈来说不存在垃圾回收的问题，只要线程一结束，该栈就结束。栈中的数据以栈帧的格式存在，栈帧是一个内存区块，是一个**数据集（变量int等），是一个有关方法和运行期数据的集合**。当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，执行完毕后，先弹出F2栈帧，再弹出F1栈帧，遵循“先进后出”原则。 

   - 堆内存：一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的**对象实例**都在这里分配内存；

     堆内存分为三部分：

     - 永久存储区：用于存放jdk自身携带的class，interface的元数据，也就说他存储的是运行环境必须的类信息，被装载至此区域的数据是不会被垃圾回收的，只有关闭JVM才能释放此区域反占用的内存。
     - 新生区
     - 老年代

   - method area（方法区）：方法区被所有线程共享，该区域保存的所有字段和字节方法以及一些特殊方法如构造函数，接口代码，**静态的常量**也再此定义。

   - PC Register（程序计数器）：程序计数器是用于存放下一条指令所在单元的地址的地方。 每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令。

2. ##### 说一下JVM运行时数据区？

   不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：

   - 程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；

   - Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；

   - 本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；

   - Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；

   - 方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。

3. ##### 说一下堆栈的区别？

   - 功能方面：堆存放对象，栈用来执行程序。
   - 共享性：堆线程共享，栈线程私有。
   - 空间大小：堆>>栈

4. ##### 队列和栈是什么？有什么区别？

   - 队列和栈都是用来存储数据的。
   - 队列先进先出，栈先进后出。

5. ##### 什么是双亲委派模型？

   在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。

   双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。 

6. ##### 说一下类装载的执行过程？

   - 加载：根据查找路径找到相应的class文件然后导入。
   - 检查：检查加载的class文件的正确性。
   - 准备：给类中静态的变量分配内存空间。
   - 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用理解为一个标识，直接引用直接指向内存地址。
   - 初始化：对静态变量和静态代码块执行初始化工作。

7. ##### 怎么判断对象是否可以被回收？

   - 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数器-1，当计数器为0时就可以被回收。
   - 可达性分析：从 GC Roots （ 是一些由堆外指向堆内的引用 ）开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 

8. ##### Java中都有哪些引用类型？

   - 强引用：java默认为强引用，发生gc的时候不会被回收。
   - 软引用：软引用是用来描述一些非必需但仍有用的对象。**在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常 。**
   - 弱引用： 弱引用的引用强度比软引用要更弱一些，**无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。** 
   - 虚引用：虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就**和没有任何引用一样，它随时可能会被回收。**用途时在gc时返回一个通知。

9. ##### 说一下JVM有哪些垃圾回收算法？

   - 标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
   - 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
   - 复制算法：按照容量划分为两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。
   - 分代算法：根据对象存存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

10. ##### 说一下JVM有哪些垃圾回收器？

    · Serial：最早的单线程串行垃圾回收器。

    · Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。

    · ParNew：是 Serial 的多线程版本。

    · Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。

    · Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。

    · CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。

    · G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。

11. ##### 详细介绍下CMS垃圾回收器？

    CMS（Concurrent Mark-Sweep）：以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常合适。在启动JVM的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 

    CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 

12. ##### 新生代垃圾回收器和老生代垃圾回收器都有哪些？有哪些区别?

    · 新生代回收器：Serial、ParNew、Parallel Scavenge

    · 老年代回收器：Serial Old、Parallel Old、CMS

    · 整堆回收器：G1

    新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。 

13. ##### 简述分代垃圾回收器是什么工作的？

    分代回收期有两个分区：老生代和新生代，新生代默认的空间占比总空间的1/3，老生代的默认占比时2/3。

    新生代使用的是复制算法，新生代里有3个分区：Eden、To Survivor、From Survior，他们的默认占比是8：1：1，执行流程如下：

    - 把 Eden + From Survivor 存活的对象放入 To Survivor 区；

    - 清空 Eden 和 From Survivor 分区；

    - From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。

    每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。

    老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。

14. ##### 说一下JVM调优的工具？

    JDK自带了很多监控工具，都位于JDK的bin目录下，其中最长用的是jconsole和jvisualvm这两款视图监控工具。

    - jconsole：用于对JVM中的内存、线程和类等进行监控。
    - jvisualvm：JDK自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc变化等。

15. ##### 常用的JVM调优的参数都有哪些？

    XX比X的稳定性更差，并且版本更新不会进行通知和说明。

    - -Xms

    s为strating，表示堆内存起始大小

    - -Xmx

    x为max，表示最大的堆内存

    （一般来说-Xms和-Xmx的设置为相同大小，因为当heap自动扩容时，会发生内存抖动，影响程序的稳定性）

    - -Xmn

    n为new，表示新生代大小

    （-Xss：规定了每个线程虚拟机栈（堆栈）的大小）

    - -XX:SurvivorRator=8

    表示堆内存中新生代、老年代和永久代的比为8:1:1

    - -XX:PretenureSizeThreshold=3145728

    表示当创建（new）的对象大于3M的时候直接进入老年代

    - -XX:MaxTenuringThreshold=15

    表示当对象的存活的年龄（minor gc一次加1）大于多少时，进入老年代

    - -XX:-DisableExplicirGC

    表示是否（+表示是，-表示否）打开GC日志