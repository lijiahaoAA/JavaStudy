15. ### JVM

    ***

    1. ##### 说一下JVM的主要组成部分？及其作用？

       [可参考]( https://www.cnblogs.com/zwbg/p/6194470.html )

       ![](https://images2015.cnblogs.com/blog/994276/201612/994276-20161218141127183-1877010567.png)

       ![](https://images2015.cnblogs.com/blog/994276/201612/994276-20161218153832964-1285100330.png)	

       - class loader（类加载器）：加载类文件到内存。只负责加载，不负责执行。

       - exectution engine（解释器/执行引擎）：负责解释命令，交由操作系统执行，是jvm的核心。

       - native interface（本地方法栈）：融合不同的语言为java所用。

       - Runtimedata area（运行时数据区）：程序被加载到这里，才开始执行。

       - stack（栈内存）：java程序的运行区，在线程创建时创建，生命周期跟随线程的生命周期。对于栈来说不存在垃圾回收的问题，只要线程一结束，该栈就结束。栈中的数据以栈帧的格式存在，栈帧是一个内存区块，是一个**数据集（变量int等），是一个有关方法和运行期数据的集合**。当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，执行完毕后，先弹出F2栈帧，再弹出F1栈帧，遵循“先进后出”原则。 

       - 堆内存：一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的**对象实例**都在这里分配内存；

         堆内存分为三部分：

         - 永久存储区：用于存放jdk自身携带的class，interface的元数据，也就说他存储的是运行环境必须的类信息，被装载至此区域的数据是不会被垃圾回收的，只有关闭JVM才能释放此区域反占用的内存。
         
         - 新生区
    
         - 老年代
      
       - method area（方法区）：方法区被所有线程共享，该区域保存的所有字段和字节方法以及一些特殊方法如构造函数，接口代码，**静态的常量**也再此定义。
      
       - PC Register（程序计数器）：程序计数器是用于存放下一条指令所在单元的地址的地方。 每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令。
       
    2. ##### 说一下JVM运行时数据区？
    
       以JDK1.8为准。不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：
    
       - 程序计数器（Program Counter Register）：线程私有，字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制（顺序执行，选择，循环，异常处理）。多线程情况下，程序计数器用于记录当前线程的执行位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪里了。
       - Java 虚拟机栈（Java Virtual Machine Stacks）：线程私有，生命周期同线程。每个Java方法在执行时会同时创建一个栈帧用于存储局部变量表（八种基本类型的数据）、操作数栈、动态链接（常量池引用信息）、方法出口等信息。
    
       - 本地方法栈（Native Method Stack）：线程私有。与虚拟机栈的作用是大致一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。
    
       - Java 堆（Java Heap）：线程共享。Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存，同时也有一小块区域用来存放运行时常量池(用于存放编译器生成的各种字面量和符号的引用）。
    
       - 方法区（Methed Area）：JDK1.8，方法区被移除，取而代之的是元空间，元空间使用的是直接内存。线程共享。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。
    
    3. ##### 说一下Java对象的创建过程。
    
       - 类加载检查：虚拟机遇到new指令后，首先去检查这个指令的参数是否能够在常量池中定位到个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、连接和初始化过。如果过没有，那必须先执行类加载过程。
       - 分配内存：类检查通过之后，虚拟机为新生对象分配内存，分配的大小是在类加载过程中确定的。这个内存是从Java堆中划分出来的。
       - 初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在Java代码中不赋初始值就能够直接使用，程序能够访问到这些字段的数据类型对应的零值。
       - 设置对象头：初始值零值完成之后，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄信息等。这些信息存放在对象头中。
       - 执行`init()`方法：new指令结束后，在Java方法中执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全生产出来。
    
    4. ##### 说一下堆栈的区别？
    
       - 功能方面：堆存放对象，栈用来执行程序。
       - 共享性：堆线程共享，栈线程私有。
       - 空间大小：堆>>栈
    
    5. ##### 队列和栈是什么？有什么区别？
    
       - 队列和栈都是用来存储数据的。
       - 队列先进先出，栈先进后出。
    
    6. ##### 什么是双亲委派模型？
    
       在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。
    
       双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。 
    
    7. ##### 说一下类装载的执行过程？
    
       - 加载：根据查找路径找到相应的class文件然后导入。
       - 检查：检查加载的class文件的正确性。
       - 准备：给类中静态的变量分配内存空间。
       - 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用理解为一个标识，直接引用直接指向内存地址。
       - 初始化：对静态变量和静态代码块执行初始化工作。
    
    8. ##### 知道那些类加载器?
    
       JVM中内置了三个重要的类加载器，除了BootstrapClassLoader其它类加载器均由Java实现且全部继承自java.lang.ClassLoader：
    
       - **BootstrapClassLoader( 启 动 类 加 载 器 ) ：**最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路重中的所有类。
       - **ExtensionClassLoader(扩展类加载器) ：**主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被java.ext.dirs 系统变最所指定的路重下的jar包
       - **AppClassLoader(应用程序类加载器) ：**面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。
    
    9. ##### 怎么判断对象是否可以被回收（或者对象死亡）？
    
       - 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数器-1，当计数器为0时就可以被回收。
       - 可达性分析：从一个名为GC Roots （ 是一些由堆外指向堆内的引用 ）的对象为起点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 
    
    10. ##### 如何判断一个常量是废弃常量？
    
       运行时常量池主要回收的是废弃的常量。
    
       假如在常量池中存在字符串“abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量“abc”是废弃常量，这时如果发生内存回收，“abc”就会被清除。
    
    11. ##### Java中都有哪些引用类型？
    
        - 强引用：java默认为强引用，发生gc的时候不会被回收，很重要。
        - 软引用：软引用是用来描述一些非必需但仍有用的对象。**在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常 。**
        - 弱引用： 弱引用的引用强度比软引用要更弱一些，**无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。** 
        - 虚引用：虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就**和没有任何引用一样，它随时可能会被回收。**用途时在gc时返回一个通知。
    
    12. ##### 说一下JVM有哪些垃圾回收算法？
    
        - 标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾空间碎片（效率和空间问题）。
        - 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动（存活对象和可回收手对象的位置不断交换），然后直接清除掉端边界以外的内存。通常为老年代使用，因为老年代对象的存活几率比较高，且没有额外的空间对他进行分配担保。
        - 复制算法：按照容量划分为两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。通常为新生代使用，应为每次收集都会有大量的对象死去，只需付出少量对象的赋值成本就可以完成。
        - 分代算法（提高GC效率）：根据对象存存活周期的不同将内存划分为几块，一般将Java堆分为新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。
    
    13. ##### 说一下JVM有哪些垃圾回收器？
    
        · **Serial：**最早的单线程串行垃圾回收器。
    
        · Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。
    
        · **ParNew：**是 Serial 的多线程版本。
    
        · Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。
    
        · Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。
    
        · **CMS：**一种以获得最短停顿时间为目标的收集器，注重用户体验，非常适用 B/S 系统。是真正实现了并发的收集器，第一次实现了让垃圾收集线程和用户线程基本上同时工作。
    
        · **G1：**一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。面向服务器，主要针对配备多颗处理器及大容量内存的机器。
    
    14. ##### 详细介绍下CMS垃圾回收器？
    
        CMS（Concurrent Mark-Sweep）：以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常合适。在启动JVM的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 
    
        CMS 使用的是标记-清除的算法实现的，所以在 GC 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 
    
    15. ##### 新生代垃圾回收器和老生代垃圾回收器都有哪些？有哪些区别?
    
        · 新生代回收器：Serial、ParNew、Parallel Scavenge
    
        · 老年代回收器：Serial Old、Parallel Old、CMS
    
        · 整堆回收器：G1
    
        新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。 
    
    16. ##### 简述分代垃圾回收器是什么工作的？
    
        分代回收期有两个分区（堆内存对象分配策略）：老生代和新生代，新生代默认的空间占比总空间的1/3，老生代的默认占比时2/3。
    
        新生代使用的是复制算法，新生代里有3个分区：Eden、To Survivor、From Survior，他们的默认占比是8：1：1，执行流程如下：
    
        - 把 Eden + From Survivor 存活的对象放入 To Survivor 区；
    
        - 清空 Eden 和 From Survivor 分区；
    
        - From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。
    
        每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。
    
        老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。
    
    17. ##### 说一下JVM调优的工具？
    
        JDK自带了很多监控工具，都位于JDK的bin目录下，其中最长用的是jconsole和jvisualvm这两款视图监控工具。
    
        - jconsole：用于对JVM中的内存、线程和类等进行监控。
        - jvisualvm：JDK自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc变化等。
    
    18. ##### 常用的JVM调优的参数都有哪些？
    
        XX比X的稳定性更差，并且版本更新不会进行通知和说明。
    
        - -Xms
    
        s为starting，表示堆内存起始大小
    
        - -Xmx
    
        x为max，表示最大的堆内存
    
        （一般来说-Xms和-Xmx的设置为相同大小，因为当heap自动扩容时，会发生内存抖动，影响程序的稳定性）
    
        - -Xmn
    
        n为new，表示新生代大小
    
        （-Xss：规定了每个线程虚拟机栈（堆栈）的大小）
    
        - -XX:SurvivorRator=8
    
        表示堆内存中新生代、老年代和永久代的比为8:1:1
    
        - -XX:PretenureSizeThreshold=3145728
    
        表示当创建（new）的对象大于3M的时候直接进入老年代
    
        - -XX:MaxTenuringThreshold=15
    
        表示当对象的存活的年龄（minor gc一次加1）大于多少时，进入老年代
    
        - -XX:-DisableExplicirGC
    
        表示是否（+表示是，-表示否）打开GC日志